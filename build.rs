use std::fs;
use std::path::Path;
use std::collections::HashMap;
use regex::Regex;
use quick_xml::Reader; // Updated to use the latest quick-xml
use quick_xml::events::Event;

// Helper to parse CLDR XML for a given locale
fn parse_cldr_keywords(path: &str) -> HashMap<String, (String, Vec<String>)> {
    let mut map = HashMap::new();
    let mut reader = Reader::from_file(path).expect("CLDR file not found");
    reader.trim_text(true);
    let mut buf = Vec::new();
    let mut cp = String::new();
    let mut tts = None;
    let mut keywords = None;

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(ref e)) if e.name().as_ref() == b"annotation" => {
                cp = e.attributes()
                    .filter_map(|a| a.ok())
                    .find(|a| a.key.as_ref() == b"cp")
                    .and_then(|a| String::from_utf8(a.value.into_owned()).ok())
                    .unwrap_or_default();
                tts = None;
                keywords = None;
                for a in e.attributes().filter_map(|a| a.ok()) {
                    if a.key.as_ref() == b"type" && a.value.as_ref() == b"tts" {
                        tts = Some(String::new());
                    }
                }
            }
            Ok(Event::Text(e)) => {
                if tts.is_some() {
                    tts = Some(e.unescape().unwrap().to_string());
                } else if !cp.is_empty() {
                    keywords = Some(
                        e.unescape().unwrap().split('|').map(|s| s.trim().to_string()).collect::<Vec<String>>()
                    );
                }
            }
            Ok(Event::End(ref e)) if e.name().as_ref() == b"annotation" => {
                if !cp.is_empty() {
                    let name = tts.clone().unwrap_or_default();
                    let kw = keywords.clone().unwrap_or_default();
                    map.insert(cp.clone(), (name, kw));
                }
                cp.clear();
                tts = None;
                keywords = None;
            }
            Ok(Event::Eof) => break,
            _ => {}
        }
        buf.clear();
    }
    map
}

fn main() {

    // Read emoji-test.txt
    let emoji_test = fs::read_to_string("data/emoji-test.txt").expect("Download emoji-test.txt first!");

    // Parse CLDR for English and Dutch
    let cldr_en = parse_cldr_keywords("data/en.xml");
    let cldr_nl = parse_cldr_keywords("data/nl.xml");

    // Parse emoji-test.txt
    let mut emojis = Vec::new();
    let mut current_category = "";
    let re = Regex::new(r"^([0-9A-F ]+); fully-qualified").unwrap();

    for line in emoji_test.lines() {
        if line.starts_with("# group:") {
            current_category = line.trim_start_matches("# group:").trim();
        } else if let Some(caps) = re.captures(line) {
            let codepoints = caps[1].split_whitespace()
                .map(|cp| u32::from_str_radix(cp, 16).unwrap())
                .collect::<Vec<_>>();
            let ch: String = codepoints.iter().filter_map(|&c| char::from_u32(c)).collect();
            let name_en = line.split('#').nth(1).unwrap().split_whitespace().skip(1).collect::<Vec<_>>().join(" ");
            // CLDR lookups
            let (name_en_cldr, keywords_en) = cldr_en.get(&ch).cloned().unwrap_or((name_en.clone(), vec![]));
            let (name_nl, keywords_nl) = cldr_nl.get(&ch).cloned().unwrap_or((name_en.clone(), vec![]));
            emojis.push((ch, name_en, keywords_en, name_nl, keywords_nl, current_category.to_string()));
        }
    }

    // Generate Rust code
    let mut out = String::from("// This file is @generated by build.rs\n\n#[derive(Clone)]\npub struct Emoji {\n    pub ch: &'static str,\n    pub name_en: &'static str,\n    pub keywords_en: &'static [&'static str],\n    pub name_nl: &'static str,\n    pub keywords_nl: &'static [&'static str],\n    pub category: &'static str,\n}\n\npub static EMOJIS: &[Emoji] = &[\n");
    for (ch, name_en, keywords_en, name_nl, keywords_nl, category) in emojis {
        let kw_en: Vec<String> = keywords_en.iter().map(|k| format!("\"{}\"", k)).collect();
        let kw_nl: Vec<String> = keywords_nl.iter().map(|k| format!("\"{}\"", k)).collect();
        out.push_str(&format!(
            "    Emoji {{ ch: \"{}\", name_en: \"{}\", keywords_en: &[{}], name_nl: \"{}\", keywords_nl: &[{}], category: \"{}\" }},\n",
            ch, name_en, kw_en.join(", "), name_nl, kw_nl.join(", "), category
        ));
    }
    out.push_str("];\n");

    fs::write(Path::new("src/emoji/emoji_data.rs"), out).expect("Failed to write emoji_data.rs");
}
