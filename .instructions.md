## 12. Architecture: Decoupled Controller and UI (Observer Pattern)

This project uses a robust, testable architecture that decouples the controller (business logic/state) from the UI using an observer (signal/callback) pattern:

- **Controller as Source of Truth:**
	- The `EmojiPickerController` manages all state and logic (mode, search, selection, etc.).
	- The controller exposes methods to mutate/query state, and a `show_category_bar()` helper for UI logic.

- **Observer Pattern for UI Updates:**
	- The controller maintains a list of listeners (callbacks) that are called whenever its state changes.
	- UI components register listeners with the controller. When the controller state changes (e.g., after `handle_search()`), it notifies all listeners.
	- The UI reacts to these notifications by updating widgets (show/hide category bar, update emoji grid, etc.) based on the controller's state.

- **Benefits:**
	- **Testability:** Controller logic is fully testable without GTK dependencies.
	- **Maintainability:** UI and logic are cleanly separated; changes to one do not require changes to the other.
	- **Extensibility:** Multiple listeners can be registered (e.g., for logging, analytics, or additional UI components).
	- **Robustness:** UI always reflects the latest controller state, reducing bugs from out-of-sync state/UI.

- **Example:**

```rust
// In controller:
pub fn add_listener<F: Fn() + 'static>(&mut self, f: F) { self.listeners.push(Box::new(f)); }
fn notify_listeners(&self) { for cb in &self.listeners { cb(); } }
// Call notify_listeners() after any state change

// In UI:
controller.borrow_mut().add_listener(move || {
		let controller = controller.borrow();
		if controller.show_category_bar() { category_scrolled.set_visible(true); }
		else { category_scrolled.set_visible(false); }
		// ...update other UI elements as needed...
});
```

This pattern is recommended for all state-driven GTK applications in Rust.
# Rust Project Best Practices

## 1. Code Style and Formatting
- Use `rustfmt` to automatically format code. Run `cargo fmt` before committing.
- Follow Rust naming conventions: snake_case for variables/functions, CamelCase for types/structs/enums.
- Keep lines under 100 characters when possible.

## 2. Error Handling
- Prefer `Result<T, E>` for recoverable errors and `panic!` only for unrecoverable situations.
- Use the `?` operator for error propagation.
- Define custom error types when needed, and implement `std::error::Error`.

## 3. Project Structure
- Organize code into modules (`mod`) and submodules for clarity.
- Use Rust's standard module conventions:
	- For a module with only one file, use `<module>.rs` (e.g., `app.rs`, `clipboard.rs`).
	- For a module with multiple related files, use a folder with a `mod.rs` file inside (e.g., `ui/mod.rs`), and place submodules in separate files within that folder (e.g., `ui/category_bar.rs`).
	- Do not use both `<foldername>.rs` and `mod.rs` in the same folder to avoid ambiguity.
	- Example:
		- `src/ui/mod.rs` (entry point for the `ui` module)
		- `src/ui/category_bar.rs`, `src/ui/emoji_grid.rs`, etc. (submodules)
		- No `src/ui.rs` if `src/ui/mod.rs` exists.
	- If you split a module into a folder, use `mod.rs` inside that folder and move related code into submodules.
- Place binaries in `src/bin/` if the project has multiple entry points.
- Keep main logic out of `main.rs`; use it to call library code from `lib.rs` or other modules.

## 4. Dependency Management
- Use the latest stable versions of dependencies unless a specific version is required.
- Regularly run `cargo update` to keep dependencies up to date.
- Avoid unnecessary dependencies to reduce compile times and binary size.

## 5. Testing

### Example: Abstracting GTK with Traits for Testability

Suppose you want your controller to update a UI label. Instead of depending directly on GTK, define a trait:

```rust
pub trait LabelView {
	fn set_text(&self, text: &str);
}

// GTK implementation
impl LabelView for gtk4::Label {
	fn set_text(&self, text: &str) {
		gtk4::Label::set_text(self, text)
	}
}

// Controller uses the trait, not GTK directly
pub struct MyController<V: LabelView> {
	label: V,
}

impl<V: LabelView> MyController<V> {
	pub fn update_label(&self, value: &str) {
		self.label.set_text(value);
	}
}

// In tests, use a mock implementation
struct MockLabel {
	pub last_text: std::cell::RefCell<String>,
}

impl LabelView for MockLabel {
	fn set_text(&self, text: &str) {
		*self.last_text.borrow_mut() = text.to_string();
	}
}

#[test]
fn test_update_label() {
	let mock = MockLabel { last_text: std::cell::RefCell::new(String::new()) };
	let controller = MyController { label: &mock };
	controller.update_label("Hello");
	assert_eq!(&*mock.last_text.borrow(), "Hello");
}
```

This pattern allows you to test controller logic without GTK or any GUI code.
- Use traits to abstract over GTK or other UI frameworks in your controller and business logic. This allows you to provide mock or test implementations for unit tests, making your codebase more testable and decoupled from the UI layer.
- Unit tests must not depend on GTK or any GUI code. Write unit tests at the bottom of the source file being tested, inside a `#[cfg(test)] mod tests { ... }` block. Do not use separate `_test.rs` files for unit tests.
- All tests that require GTK or GUI components must be written as integration tests in the `tests/` directory. These tests are run as binaries and always start on the main thread, which is required by GTK.
- Run `cargo test` before pushing changes.

## 6. Documentation
- Document all public items with `///` doc comments.
- Provide examples in documentation where helpful.
- Generate docs with `cargo doc --open` to review.

## 7. Version Control
- Commit early and often with clear, descriptive messages.
- Do not commit generated files or build artifacts.
- Use `.gitignore` to exclude target/, .DS_Store, and other non-source files.

## 8. Continuous Integration
- Set up CI to run `cargo fmt --check`, `cargo clippy`, and `cargo test` on every PR.

## 9. Linting
- Use `cargo clippy` to catch common mistakes and improve code quality.
- Address all warnings unless there is a strong reason not to (document exceptions).

## 10. Security
- Run `cargo audit` regularly to check for vulnerable dependencies.

## 11. UI Guidelines
- Use GTK4 conventions for UI components. and don't deviate too much from the examples provided in https://github.com/gtk-rs/gtk4-rs/tree/main/examples

---

Feel free to expand this file with project-specific rules or additional sections as needed.
